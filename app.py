import io
import json
from flask import Flask, render_template, request, send_file
from flask import Flask, request, jsonify, send_file
from pathlib import Path
from pptx import Presentation
from openai import OpenAI

app = Flask(__name__)
client = OpenAI()  # uses OPENAI_API_KEY from environment

SYSTEM_PROMPT = """You create presentation content as strict JSON.
Return ONLY valid JSON, no markdown, no extra text.

Schema:
{
  "title": "string",
  "slides": [
    {
      "title": "string",
      "bullets": ["string", "string", "string"],
      "speaker_notes": "string"
    }
  ]
}
Rules:
- bullets should be short and clear
- exactly 3 bullets per slide
- speaker_notes: 2-4 sentences
"""

def build_pptx(data):
    prs = Presentation()

    # Title slide
    slide = prs.slides.add_slide(prs.slide_layouts[0])
    slide.shapes.title.text = data.get("title", "Presentation")
    slide.placeholders[1].text = "Generated by AI"

    # Content slides
    for s in data.get("slides", []):
        slide = prs.slides.add_slide(prs.slide_layouts[1])
        slide.shapes.title.text = s.get("title", "Slide")

        tf = slide.placeholders[1].text_frame
        tf.clear()

        for i, bullet in enumerate(s.get("bullets", [])[:3]):
            p = tf.paragraphs[0] if i == 0 else tf.add_paragraph()
            p.text = bullet
            p.level = 0

        notes = s.get("speaker_notes", "")
        if notes:
            slide.notes_slide.notes_text_frame.text = notes

    buf = io.BytesIO()
    prs.save(buf)
    buf.seek(0)
    return buf

from ppt.builder_team_sas import build_presentation

@app.post("/generate")
def generate():
    data = request.get_json(force=True)

    topic = data.get("topic", "Untitled Topic")
    slides = data.get("slides", [])

    # default 10-slide structure if user sends only topic
    if not slides:
        slides = [
            {"type": "title", "title": topic, "subtitle": "Generated by AI"},
            {"type": "context", "title": "Context", "bullets": ["Why this matters", "What problem we solve", "Who is impacted"]},
            {"type": "research_question", "title": "Research Question", "bullets": ["Main question", "Key variables", "Expected relationship"]},
            {"type": "datasets", "title": "Data Sources", "bullets": ["Dataset 1", "Dataset 2", "Key columns / size"]},
            {"type": "features", "title": "Engineered Features", "bullets": ["Feature 1", "Feature 2", "Feature 3"]},
            {"type": "finding", "title": "Key Finding 1", "bullets": ["Result", "Stat", "Interpretation"]},
            {"type": "finding", "title": "Key Finding 2", "bullets": ["Result", "Stat", "Interpretation"]},
            {"type": "finding", "title": "Key Finding 3", "bullets": ["Result", "Stat", "Interpretation"]},
            {"type": "validation", "title": "Statistical Validation", "bullets": ["Test used", "p-value / model", "Conclusion"]},
            {"type": "conclusion", "title": "Conclusion", "bullets": ["Takeaway 1", "Takeaway 2", "Future work"]},
        ]

    out_path = build_presentation(topic, slides, output_dir="output")
    filename = Path(out_path).name

    return jsonify({
        "ok": True,
        "file": filename,
        "download_url": f"/download/{filename}"
    })


@app.get("/download/<filename>")
def download(filename):
    path = Path("output") / filename
    return send_file(path, as_attachment=True)

if __name__ == "__main__":
    app.run(debug=True)
